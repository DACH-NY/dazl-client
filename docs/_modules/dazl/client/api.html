<!DOCTYPE html>
<html lang="" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dazl.client.api</title>
  

  <link rel="apple-touch-icon" sizes="180x180" href="../../../_static/apple-touch-icon.png"/>
  <link rel="icon" type="image/png" href="../../../_static/favicon-32x32.png" sizes="32x32"/>
  <link rel="icon" type="image/png" href="../../../_static/favicon-16x16.png" sizes="16x16"/>
  <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="dazl unknown documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 
</head>
<body>

   

  <header>
    dazl

  </header>
  <nav>
              
              
                
              
              
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../migrating.html">Migrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dazl.html">dazl package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

              

  </nav>
  <main>
    
  <h1>Source code for dazl.client.api</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.</span>
<span class="c1"># SPDX-License-Identifier: Apache-2.0</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the public API for interacting with the ledger from the perspective of a</span>
<span class="sd">specific party.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># NOTE TO IMPLEMENTORS</span>
<span class="c1">#</span>
<span class="c1"># This file contains only public API definitions, overloads, and documentation. (This file should</span>
<span class="c1"># be treated more like a C header file than anything else.) The bulk of the implementation is kept</span>
<span class="c1"># in _party_client.py.</span>
<span class="c1">#</span>
<span class="c1"># This file is repetitive and tedious, but written this way primarily so that static typing tools</span>
<span class="c1"># do the right thing. Python&#39;s ``typing`` library (and mypy) aren&#39;t quite expressive enough to allow</span>
<span class="c1"># for a more concise representation of the various flavors of the API. The unit test</span>
<span class="c1"># ``test_api_consistency.py`` verifies that these implementations are generally in sync with each</span>
<span class="c1"># other the way that the documentation says they are.</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">from</span> <span class="nn">asyncio</span> <span class="k">import</span> <span class="n">get_event_loop</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span><span class="p">,</span> <span class="n">ExitStack</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="k">import</span> <span class="n">INFO</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="k">import</span> <span class="n">uuid4</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="k">import</span> <span class="n">current_thread</span><span class="p">,</span> <span class="n">main_thread</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Awaitable</span><span class="p">,</span> <span class="n">BinaryIO</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">ContextManager</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> \
    <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">LOG</span>
<span class="kn">from</span> <span class="nn">.bots</span> <span class="k">import</span> <span class="n">Bot</span><span class="p">,</span> <span class="n">BotCollection</span>
<span class="kn">from</span> <span class="nn">.config</span> <span class="k">import</span> <span class="n">AnonymousNetworkConfig</span><span class="p">,</span> <span class="n">NetworkConfig</span><span class="p">,</span> <span class="n">PartyConfig</span>
<span class="kn">from</span> <span class="nn">._base_model</span> <span class="k">import</span> <span class="n">IfMissingPartyBehavior</span><span class="p">,</span> <span class="n">CREATE_IF_MISSING</span>
<span class="kn">from</span> <span class="nn">..damlsdk.sandbox</span> <span class="k">import</span> <span class="n">sandbox</span>
<span class="kn">from</span> <span class="nn">..metrics</span> <span class="k">import</span> <span class="n">MetricEvents</span>
<span class="kn">from</span> <span class="nn">..model.core</span> <span class="k">import</span> <span class="n">ContractId</span><span class="p">,</span> <span class="n">ContractData</span><span class="p">,</span> <span class="n">ContractsState</span><span class="p">,</span> <span class="n">ContractMatch</span><span class="p">,</span> \
    <span class="n">ContractContextualData</span><span class="p">,</span> <span class="n">ContractContextualDataCollection</span><span class="p">,</span> <span class="n">Party</span><span class="p">,</span> <span class="n">RunLevel</span>
<span class="kn">from</span> <span class="nn">..model.ledger</span> <span class="k">import</span> <span class="n">LedgerMetadata</span>
<span class="kn">from</span> <span class="nn">..model.reading</span> <span class="k">import</span> <span class="n">InitEvent</span><span class="p">,</span> <span class="n">ReadyEvent</span><span class="p">,</span> <span class="n">ContractCreateEvent</span><span class="p">,</span> <span class="n">ContractExercisedEvent</span><span class="p">,</span> \
    <span class="n">ContractArchiveEvent</span><span class="p">,</span> <span class="n">TransactionStartEvent</span><span class="p">,</span> <span class="n">TransactionEndEvent</span><span class="p">,</span> <span class="n">PackagesAddedEvent</span><span class="p">,</span> <span class="n">EventKey</span>
<span class="kn">from</span> <span class="nn">..model.types</span> <span class="k">import</span> <span class="n">TemplateNameLike</span>
<span class="kn">from</span> <span class="nn">..model.writing</span> <span class="k">import</span> <span class="n">EventHandlerResponse</span>
<span class="kn">from</span> <span class="nn">..util.asyncio_util</span> <span class="k">import</span> <span class="n">await_then</span>
<span class="kn">from</span> <span class="nn">..util.io</span> <span class="k">import</span> <span class="n">get_bytes</span>
<span class="kn">from</span> <span class="nn">..util.prim_types</span> <span class="k">import</span> <span class="n">TimeDeltaConvertible</span>
<span class="kn">from</span> <span class="nn">._events</span> <span class="k">import</span> <span class="n">EventHandler</span><span class="p">,</span> <span class="n">AEventHandler</span><span class="p">,</span> <span class="n">EventHandlerDecorator</span><span class="p">,</span> <span class="n">AEventHandlerDecorator</span><span class="p">,</span> \
    <span class="n">fluentize</span>
<span class="kn">from</span> <span class="nn">._network_client_impl</span> <span class="k">import</span> <span class="n">_NetworkImpl</span>
<span class="kn">from</span> <span class="nn">._party_client_impl</span> <span class="k">import</span> <span class="n">_PartyClientImpl</span>
<span class="kn">from</span> <span class="nn">._run_level</span> <span class="k">import</span> <span class="n">RunState</span>


<span class="n">DEFAULT_TIMEOUT_SECONDS</span> <span class="o">=</span> <span class="mi">30</span>


<div class="viewcode-block" id="simple_client"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.simple_client">[docs]</a><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">simple_client</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">party</span><span class="p">:</span> <span class="s1">&#39;Union[None, str, Party]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">log_level</span><span class="p">:</span> <span class="s1">&#39;Optional[int]&#39;</span> <span class="o">=</span> <span class="n">INFO</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="s1">&#39;ContextManager[SimplePartyClient]&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Start up a single client connecting to a single specific party.</span>

<span class="sd">    :param url:</span>
<span class="sd">        The URL of the client to connect to. Defaults to the value of the ``DAML_LEDGER_URL``</span>
<span class="sd">        environment variable (if set).</span>
<span class="sd">    :param party:</span>
<span class="sd">        The party to connect as. Defaults to the value of the ``DAML_LEDGER_PARTY`` environment</span>
<span class="sd">        variable if it is set.</span>
<span class="sd">    :param log_level:</span>
<span class="sd">        If non-``None``, configure a default logger that logs output at the specified level. The</span>
<span class="sd">        default value is ``INFO``.</span>
<span class="sd">    :return:</span>
<span class="sd">        A :class:`SimplePartyClient` that can be used in a completely blocking, synchronous</span>
<span class="sd">        fashion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">log_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">setup_default_logger</span>
        <span class="n">setup_default_logger</span><span class="p">(</span><span class="n">log_level</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">os</span>
    <span class="k">if</span> <span class="n">url</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;DAML_LEDGER_URL&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">party</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">party</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;DAML_LEDGER_PARTY&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;url must be specified, or the DAML_LEDGER_URL environment variable &#39;</span>
                         <span class="s1">&#39;must be set&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">party</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;party must be specified, or the DAML_LEDGER_PARTY environment variable &#39;</span>
                         <span class="s1">&#39;must be set&#39;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">context_manager</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting a simple_client with to </span><span class="si">%s</span><span class="s1"> with party </span><span class="si">%r</span><span class="s1">...&#39;</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">party</span><span class="p">)</span>
        <span class="n">parsed_url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parsed_url</span><span class="o">.</span><span class="n">scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parsed_url</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;sandbox&#39;</span><span class="p">:</span>
            <span class="c1"># start a local in-memory sandbox first</span>
            <span class="n">daml_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;DAML_LEDGER_DAR_PATH&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">))</span>

            <span class="n">daml_artifacts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[Path]</span>
            <span class="n">daml_artifacts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">daml_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;**/*.dar&#39;</span><span class="p">))</span>
            <span class="n">daml_artifacts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">daml_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;**/*.dalf&#39;</span><span class="p">))</span>

            <span class="n">sandbox_proc</span> <span class="o">=</span> <span class="n">sandbox</span><span class="p">(</span><span class="n">daml_path</span><span class="o">=</span><span class="n">daml_artifacts</span><span class="p">)</span>
            <span class="n">url</span> <span class="o">=</span> <span class="n">context_manager</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">sandbox_proc</span><span class="p">)</span><span class="o">.</span><span class="n">url</span>

        <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>
        <span class="n">network</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">)</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">simple_party</span><span class="p">(</span><span class="n">party</span><span class="p">)</span>

        <span class="n">network</span><span class="o">.</span><span class="n">start_in_background</span><span class="p">()</span>

        <span class="k">yield</span> <span class="n">client</span>

        <span class="n">network</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
        <span class="n">network</span><span class="o">.</span><span class="n">join</span><span class="p">()</span></div>


<div class="viewcode-block" id="Network"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network">[docs]</a><span class="k">class</span> <span class="nc">Network</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manages network connection/scheduling logic on behalf of one or more :class:`PartyClient`</span>
<span class="sd">    instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="s1">&#39;Optional[MetricEvents]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span> <span class="o">=</span> <span class="n">_NetworkImpl</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span>

<div class="viewcode-block" id="Network.set_config"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.set_config">[docs]</a>    <span class="k">def</span> <span class="nf">set_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="o">*</span><span class="n">config</span><span class="p">:</span> <span class="s1">&#39;Union[NetworkConfig, AnonymousNetworkConfig]&#39;</span><span class="p">,</span>
            <span class="n">url</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">admin_url</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="o">*</span><span class="n">config</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="n">admin_url</span><span class="o">=</span><span class="n">admin_url</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.resolved_config"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.resolved_config">[docs]</a>    <span class="k">def</span> <span class="nf">resolved_config</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;NetworkConfig&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the configuration that will be used for this client when it is instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">resolved_config</span><span class="p">()</span></div>

    <span class="c1"># &lt;editor-fold desc=&quot;Global/Party client creation&quot;&gt;</span>

<div class="viewcode-block" id="Network.simple_global"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.simple_global">[docs]</a>    <span class="k">def</span> <span class="nf">simple_global</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SimpleGlobalClient&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :class:`GlobalClient` that exposes thread-safe, synchronous (blocking) methods for</span>
<span class="sd">        communicating with a ledger. Callbacks are dispatched to background threads.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">global_impl</span><span class="p">(</span><span class="n">SimpleGlobalClient</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.aio_global"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.aio_global">[docs]</a>    <span class="k">def</span> <span class="nf">aio_global</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AIOGlobalClient&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :class:`GlobalClient` that works on an asyncio event loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">global_impl</span><span class="p">(</span><span class="n">AIOGlobalClient</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.simple_party"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.simple_party">[docs]</a>    <span class="k">def</span> <span class="nf">simple_party</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">party</span><span class="p">:</span> <span class="s1">&#39;Union[str, Party]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SimplePartyClient&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :class:`PartyClient` that exposes thread-safe, synchronous (blocking) methods for</span>
<span class="sd">        communicating with a ledger. Callbacks are dispatched to background threads.</span>

<span class="sd">        :param party: The party to get a client for.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">party_impl</span><span class="p">(</span><span class="n">Party</span><span class="p">(</span><span class="n">party</span><span class="p">),</span> <span class="n">SimplePartyClient</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.aio_party"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.aio_party">[docs]</a>    <span class="k">def</span> <span class="nf">aio_party</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">party</span><span class="p">:</span> <span class="s1">&#39;Union[str, Party]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AIOPartyClient&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :class:`PartyClient` that works on an asyncio event loop.</span>

<span class="sd">        :param party: The party to get a client for.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">party_impl</span><span class="p">(</span><span class="n">Party</span><span class="p">(</span><span class="n">party</span><span class="p">),</span> <span class="n">AIOPartyClient</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.party_bots"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.party_bots">[docs]</a>    <span class="k">def</span> <span class="nf">party_bots</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">party</span><span class="p">:</span> <span class="s1">&#39;Union[str, Party]&#39;</span><span class="p">,</span>
            <span class="n">if_missing</span><span class="p">:</span> <span class="n">IfMissingPartyBehavior</span> <span class="o">=</span> <span class="n">CREATE_IF_MISSING</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;BotCollection&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the collection of bots associated with a party.</span>

<span class="sd">        :param party: The party to get bots for.</span>
<span class="sd">        :param if_missing:</span>
<span class="sd">            Specify the behavior to use in the case where no client has been yet requested for this</span>
<span class="sd">            party. The default behavior is CREATE_IF_MISSING.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">party_impl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">party_impl</span><span class="p">(</span><span class="n">party</span><span class="p">,</span> <span class="n">if_missing</span><span class="o">=</span><span class="n">if_missing</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">party_impl</span><span class="o">.</span><span class="n">bots</span> <span class="k">if</span> <span class="n">party_impl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Daemon thread-based scheduling API&quot;&gt;</span>

<div class="viewcode-block" id="Network.start_in_background"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.start_in_background">[docs]</a>    <span class="k">def</span> <span class="nf">start_in_background</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">daemon</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">install_signal_handlers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect to the ledger in a background thread.</span>

<span class="sd">        The current thread does NOT block. Operations on instances of :class:`SimplePartyClient`</span>
<span class="sd">        are allowed, and operations on instances of :class:`AIOPartyClient` are allowed as long as</span>
<span class="sd">        they are made from the correct thread.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">install_signal_handlers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_thread</span><span class="p">()</span> <span class="ow">is</span> <span class="n">main_thread</span><span class="p">():</span>
                <span class="n">install_signal_handlers</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">install_signal_handlers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_thread</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">main_thread</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;tried to install signal handlers when not on the main thread&#39;</span><span class="p">)</span>

        <span class="n">run_state</span> <span class="o">=</span> <span class="n">RunState</span><span class="p">(</span><span class="n">RunLevel</span><span class="o">.</span><span class="n">RUN_FOREVER</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">install_signal_handlers</span><span class="p">:</span>
            <span class="c1"># the main loop will be run from a background thread, so do NOT use asyncio directly</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">_</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">shutdown</span><span class="p">())</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">_</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">abort</span><span class="p">())</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="c1"># SIGINIT and SIGQUIT handlers are not supported on Windows.</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">run_state</span><span class="p">,</span> <span class="n">daemon</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.shutdown"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.shutdown">[docs]</a>    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gracefully shut down all network connections and notify all clients that they are about to</span>
<span class="sd">        be terminated.</span>

<span class="sd">        The current thread does NOT block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span></div>

<div class="viewcode-block" id="Network.join"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="s1">&#39;Optional[float]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Block the current thread until the client is shut down.</span>

<span class="sd">        :param timeout:</span>
<span class="sd">            Number of seconds to wait before timing out the join, or ``None`` to wait indefinitely.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>

    <span class="c1"># &lt;editor-fold desc=&quot;asyncio-based scheduling API&quot;&gt;</span>

    <span class="k">def</span> <span class="nf">_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_run_level</span><span class="p">,</span> <span class="o">*</span><span class="n">coroutines</span><span class="p">:</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">,</span>
             <span class="n">install_signal_handlers</span><span class="p">:</span> <span class="s1">&#39;Optional[bool]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">install_signal_handlers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_thread</span><span class="p">()</span> <span class="ow">is</span> <span class="n">main_thread</span><span class="p">():</span>
                <span class="n">install_signal_handlers</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">install_signal_handlers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_thread</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">main_thread</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;tried to install signal handlers when not on the main thread&#39;</span><span class="p">)</span>

        <span class="n">run_state</span> <span class="o">=</span> <span class="n">RunState</span><span class="p">(</span><span class="n">initial_run_level</span><span class="p">)</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">get_event_loop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">install_signal_handlers</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">run_state</span><span class="o">.</span><span class="n">handle_sigint</span><span class="p">)</span>
                <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">run_state</span><span class="o">.</span><span class="n">handle_sigquit</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="c1"># SIGINT and SIGQUIT are not supported on Windows.</span>
                <span class="k">pass</span>

        <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aio_run</span><span class="p">(</span><span class="o">*</span><span class="n">coroutines</span><span class="p">,</span> <span class="n">run_state</span><span class="o">=</span><span class="n">run_state</span><span class="p">))</span>

<div class="viewcode-block" id="Network.run_until_complete"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.run_until_complete">[docs]</a>    <span class="k">def</span> <span class="nf">run_until_complete</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">coroutines</span><span class="p">:</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">,</span>
            <span class="n">install_signal_handlers</span><span class="p">:</span> <span class="s1">&#39;Optional[bool]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Block the main thread and run the application in an event loop on the main thread. The loop</span>
<span class="sd">        terminates when the given (optional) coroutines terminate OR :meth:`shutdown` is called AND</span>
<span class="sd">        all active command submissions and event handlers&#39; follow-ups have successfully returned.</span>

<span class="sd">        :param coroutines:</span>
<span class="sd">            Coroutines to run alongside event handlers and command submissions. When these</span>
<span class="sd">            coroutines are done running and the</span>
<span class="sd">        :param install_signal_handlers:</span>
<span class="sd">            ``True`` to install SIGINT and SIGQUIT event handlers (CTRL+C and CTRL+\\);</span>
<span class="sd">            ``False`` to skip installation. The default value is ``None``, which installs signal</span>
<span class="sd">            handlers only when called from the main thread (default). If signal handlers are</span>
<span class="sd">            requested to be installed and the thread is NOT the main thread, this method throws.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run</span><span class="p">(</span><span class="n">RunLevel</span><span class="o">.</span><span class="n">RUN_UNTIL_IDLE</span><span class="p">,</span> <span class="o">*</span><span class="n">coroutines</span><span class="p">,</span>
                  <span class="n">install_signal_handlers</span><span class="o">=</span><span class="n">install_signal_handlers</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The internal run_until_complete event loop has now completed.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.run_forever"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.run_forever">[docs]</a>    <span class="k">def</span> <span class="nf">run_forever</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">coroutines</span><span class="p">:</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">,</span>
            <span class="n">install_signal_handlers</span><span class="p">:</span> <span class="s1">&#39;Optional[bool]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Block the main thread and run the application in an event loop on the main thread. The loop</span>
<span class="sd">        terminates when :meth:`shutdown` is called AND all active command submissions and event</span>
<span class="sd">        handlers&#39; follow-ups have successfully returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run</span><span class="p">(</span><span class="n">RunLevel</span><span class="o">.</span><span class="n">RUN_FOREVER</span><span class="p">,</span> <span class="o">*</span><span class="n">coroutines</span><span class="p">,</span>
                  <span class="n">install_signal_handlers</span><span class="o">=</span><span class="n">install_signal_handlers</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The internal run_forever event loop has been shut down.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Network.aio_run"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.aio_run">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">aio_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">coroutines</span><span class="p">,</span> <span class="n">run_state</span><span class="p">:</span> <span class="s1">&#39;Optional[RunState]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Coroutine where all network activity is scheduled from. This coroutine exits when</span>
<span class="sd">        :meth:`shutdown` is called, and can be used directly as an asyncio-native alternative to</span>
<span class="sd">        :meth:`start_in_background` and :meth:`join`.</span>

<span class="sd">        You would normally call this method directly only if you are trying to incorporate</span>
<span class="sd">        the client into an already-running event loop. Prefer :meth:`run_until_complete` or</span>
<span class="sd">        :meth:`run_forever` if you can block the current thread, or :meth:`start_in_background`</span>
<span class="sd">        with :meth:`join` if you wish to run the entire client on background threads.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">aio_run</span><span class="p">(</span><span class="o">*</span><span class="n">coroutines</span><span class="p">,</span> <span class="n">run_state</span><span class="o">=</span><span class="n">run_state</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The aio_run coroutine has completed.&#39;</span><span class="p">)</span></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>

<div class="viewcode-block" id="Network.parties"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.parties">[docs]</a>    <span class="k">def</span> <span class="nf">parties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Collection[Party]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a snapshot of the set of parties that exist right now.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">parties</span><span class="p">()</span></div>

<div class="viewcode-block" id="Network.bots"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.Network.bots">[docs]</a>    <span class="k">def</span> <span class="nf">bots</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Collection[Bot]&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">bots</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="GlobalClient"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.GlobalClient">[docs]</a><span class="k">class</span> <span class="nc">GlobalClient</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Public interface for either an async-based or a thread-safe version of an API for interacting</span>
<span class="sd">    with a Ledger API implementation that manages global ledger data, such as package store</span>
<span class="sd">    management and current time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">impl</span><span class="p">:</span> <span class="s1">&#39;_NetworkImpl&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span> <span class="o">=</span> <span class="n">impl</span></div>


<div class="viewcode-block" id="AIOGlobalClient"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOGlobalClient">[docs]</a><span class="k">class</span> <span class="nc">AIOGlobalClient</span><span class="p">(</span><span class="n">GlobalClient</span><span class="p">):</span>

<div class="viewcode-block" id="AIOGlobalClient.ensure_dar"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOGlobalClient.ensure_dar">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">ensure_dar</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">contents</span><span class="p">:</span> <span class="s1">&#39;Union[str, Path, bytes, BinaryIO]&#39;</span><span class="p">,</span>
            <span class="n">timeout</span><span class="p">:</span> <span class="s1">&#39;TimeDeltaConvertible&#39;</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that the ledger has the packages specified by the given contents (as a byte array).</span>
<span class="sd">        Throw an exception if the specified DARs do not exist within the specified timeout.</span>

<span class="sd">        :param contents: The DAR or DALF to ensure.</span>
<span class="sd">        :param timeout: The maximum length of time to wait before giving up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raw_bytes</span> <span class="o">=</span> <span class="n">get_bytes</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">upload_package</span><span class="p">(</span><span class="n">raw_bytes</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOGlobalClient.ensure_packages"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOGlobalClient.ensure_packages">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">ensure_packages</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">package_ids</span><span class="p">:</span> <span class="s1">&#39;Collection[str]&#39;</span><span class="p">,</span>
            <span class="n">timeout</span><span class="p">:</span> <span class="s1">&#39;TimeDeltaConvertible&#39;</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that packages with the specified package IDs exist on the ledger. Throw an</span>
<span class="sd">        exception if the specified packages do not exist within the specified timeout.</span>

<span class="sd">        :param package_ids: The set of package IDs to check for.</span>
<span class="sd">        :param timeout: The maximum length of time to wait before giving up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">ensure_package_ids</span><span class="p">(</span><span class="n">package_ids</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOGlobalClient.metadata"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOGlobalClient.metadata">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LedgerMetadata</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current set of known packages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">aio_metadata</span><span class="p">()</span></div>

<div class="viewcode-block" id="AIOGlobalClient.get_time"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOGlobalClient.get_time">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span></div>

<div class="viewcode-block" id="AIOGlobalClient.set_time"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOGlobalClient.set_time">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">set_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_datetime</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">set_time</span><span class="p">(</span><span class="n">new_datetime</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SimpleGlobalClient"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimpleGlobalClient">[docs]</a><span class="k">class</span> <span class="nc">SimpleGlobalClient</span><span class="p">(</span><span class="n">GlobalClient</span><span class="p">):</span>

<div class="viewcode-block" id="SimpleGlobalClient.ensure_dar"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimpleGlobalClient.ensure_dar">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_dar</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">contents</span><span class="p">:</span> <span class="s1">&#39;Union[str, Path, bytes, BinaryIO]&#39;</span><span class="p">,</span>
            <span class="n">timeout</span><span class="p">:</span> <span class="s1">&#39;TimeDeltaConvertible&#39;</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that the ledger has the packages specified by the given contents (as a byte array).</span>
<span class="sd">        Throw an exception if the specified DARs do not exist within the specified timeout.</span>

<span class="sd">        :param contents: The DAR or DALF to ensure.</span>
<span class="sd">        :param timeout: The maximum length of time to wait before giving up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raw_bytes</span> <span class="o">=</span> <span class="n">get_bytes</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">run_in_loop_threadsafe</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">upload_package</span><span class="p">(</span><span class="n">raw_bytes</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimpleGlobalClient.ensure_packages"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimpleGlobalClient.ensure_packages">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_packages</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">package_ids</span><span class="p">:</span> <span class="s1">&#39;Collection[str]&#39;</span><span class="p">,</span>
            <span class="n">timeout</span><span class="p">:</span> <span class="s1">&#39;TimeDeltaConvertible&#39;</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that packages with the specified package IDs exist on the ledger. Throw an</span>
<span class="sd">        exception if the specified packages do not exist within the specified timeout.</span>

<span class="sd">        :param package_ids: The set of package IDs to check for.</span>
<span class="sd">        :param timeout: The maximum length of time to wait before giving up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">run_in_loop_threadsafe</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">ensure_package_ids</span><span class="p">(</span><span class="n">package_ids</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimpleGlobalClient.metadata"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimpleGlobalClient.metadata">[docs]</a>    <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="s1">&#39;TimeDeltaConvertible&#39;</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;LedgerMetadata&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current set of known packages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">simple_metadata</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleGlobalClient.get_time"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimpleGlobalClient.get_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">run_in_loop_threadsafe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_time</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleGlobalClient.set_time"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimpleGlobalClient.set_time">[docs]</a>    <span class="k">def</span> <span class="nf">set_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_datetime</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">run_in_loop_threadsafe</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">set_time</span><span class="p">(</span><span class="n">new_datetime</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="PartyClient"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.PartyClient">[docs]</a><span class="k">class</span> <span class="nc">PartyClient</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Public interface for either an async-based or a thread-safe version of an API for interacting</span>
<span class="sd">    with a Ledger API implementation from the perspective of a single client.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">impl</span><span class="p">:</span> <span class="s1">&#39;_PartyClientImpl&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span> <span class="o">=</span> <span class="n">impl</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Ledger/client metadata&quot;&gt;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">party</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Party&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the party serviced by this client.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">party</span>

<div class="viewcode-block" id="PartyClient.resolved_config"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.PartyClient.resolved_config">[docs]</a>    <span class="k">def</span> <span class="nf">resolved_config</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;PartyConfig&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the configuration that will be used for this client when it is instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">resolved_config</span><span class="p">()</span></div></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>


<div class="viewcode-block" id="AIOPartyClient"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient">[docs]</a><span class="k">class</span> <span class="nc">AIOPartyClient</span><span class="p">(</span><span class="n">PartyClient</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of a :class:`PartyClient` that exposes an `async`/`await`-style API that runs on</span>
<span class="sd">    an event loop.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Event handler registration&quot;&gt;</span>

<div class="viewcode-block" id="AIOPartyClient.ledger_init"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ledger_init">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandlerDecorator[InitEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` has been</span>
<span class="sd">        instructed to begin, but before any network activity is started.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_init</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.add_ledger_init"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.add_ledger_init">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[InitEvent]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` has been instructed to</span>
<span class="sd">        begin, but before any network activity is started.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. This can either be a coroutine or a normal function, and may</span>
<span class="sd">            return anything that can be successfully coerced into a :class:`CommandPayload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">init</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.ledger_ready"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ledger_ready">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandlerDecorator[ReadyEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` has caught</span>
<span class="sd">        up to the head of the ledger, but before any :meth:`ledger_create` or :meth:`ledger_archive`</span>
<span class="sd">        callbacks are invoked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_ready</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.add_ledger_ready"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.add_ledger_ready">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[ReadyEvent]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` has caught up to the head of</span>
<span class="sd">        the ledger, but before any :meth:`ledger_create` or :meth:`ledger_archive` callbacks are</span>
<span class="sd">        invoked.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. This can either be a coroutine or a normal function, and may</span>
<span class="sd">            return anything that can be successfully coerced into a :class:`CommandPayload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">ready</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.ledger_packages_added"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ledger_packages_added">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_packages_added</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandlerDecorator[PackagesAddedEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` has</span>
<span class="sd">        detected new packages added to the ledger.</span>

<span class="sd">        :param initial:</span>
<span class="sd">            ``True`` to call the handler when the client is ready. This can be useful if you want</span>
<span class="sd">            to handle package additions identically whether they were already in the ledger when</span>
<span class="sd">            the client started up or only after a package has been added. The default value is</span>
<span class="sd">            ``False``, which means that this handler is only called on NEW packages that have been</span>
<span class="sd">            uploaded after this client has started.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_packages_added</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.add_ledger_packages_added"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.add_ledger_packages_added">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_packages_added</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[PackagesAddedEvent]&#39;</span><span class="p">,</span> <span class="n">initial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` has detected new packages</span>
<span class="sd">        added to the ledger.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. This can either be a coroutine or a normal function, and may</span>
<span class="sd">            return anything that can be successfully coerced into a :class:`CommandPayload`.</span>
<span class="sd">        :param initial:</span>
<span class="sd">            ``True`` to call the handler when the client is ready. This can be useful if you want</span>
<span class="sd">            to handle package additions identically whether they were already in the ledger when</span>
<span class="sd">            the client started up or only after a package has been added. The default value is</span>
<span class="sd">            ``False``, which means that this handler is only called on NEW packages that have been</span>
<span class="sd">            uploaded after this client has started.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">packages_added</span><span class="p">(</span><span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">changed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.ledger_transaction_start"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ledger_transaction_start">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_transaction_start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandlerDecorator[TransactionStartEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` receives a</span>
<span class="sd">        new transaction. Called before individual :meth:`ledger_create` and :meth:`ledger_archive`</span>
<span class="sd">        callbacks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_transaction_start</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.add_ledger_transaction_start"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.add_ledger_transaction_start">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_transaction_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[TransactionStartEvent]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` receives a new transaction.</span>
<span class="sd">        Called before individual :meth:`ledger_create` and :meth:`ledger_archive` callbacks.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. This can either be a coroutine or a normal function, and may</span>
<span class="sd">            return anything that can be successfully coerced into a :class:`CommandPayload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">transaction_start</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.ledger_transaction_end"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ledger_transaction_end">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_transaction_end</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandlerDecorator[TransactionEndEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` receives a</span>
<span class="sd">        new transaction. Called after individual :meth:`ledger_create` and :meth:`ledger_archive`</span>
<span class="sd">        callbacks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_transaction_end</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.add_ledger_transaction_end"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.add_ledger_transaction_end">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_transaction_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[TransactionEndEvent]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` receives a new transaction.</span>
<span class="sd">        Called after individual :meth:`ledger_create` and :meth:`ledger_archive` callbacks.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. This can either be a coroutine or a normal function, and may</span>
<span class="sd">            return anything that can be successfully coerced into a :class:`CommandPayload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">transaction_end</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.ledger_created"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ledger_created">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_created</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;Optional[ContractMatch]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandlerDecorator[ContractCreateEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters a newly created</span>
<span class="sd">        template.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An (optional) parameter that filters the templates to be received by the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_register_created</span><span class="p">(</span><span class="n">cb</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[ContractCreateEvent]&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandler[ContractCreateEvent]&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_created</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">cb</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cb</span>

        <span class="k">return</span> <span class="n">_register_created</span></div>

<div class="viewcode-block" id="AIOPartyClient.add_ledger_created"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.add_ledger_created">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_created</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[ContractCreateEvent]&#39;</span><span class="p">,</span>
            <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;Optional[ContractMatch]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Bot&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters a newly created</span>
<span class="sd">        contract instance of a template.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param handler:</span>
<span class="sd">            The callback to invoke whenever a matching template is created.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An (optional) parameter that filters the templates to be received by the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">bots</span><span class="o">.</span><span class="n">add_new</span><span class="p">(</span><span class="n">party_client</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">handler</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">bot</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">EventKey</span><span class="o">.</span><span class="n">contract_created</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">template</span><span class="p">),</span> <span class="n">handler</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bot</span></div>

<div class="viewcode-block" id="AIOPartyClient.ledger_exercised"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ledger_exercised">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_exercised</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandlerDecorator[ContractExercisedEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters an exercised</span>
<span class="sd">        choice event.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param choice:</span>
<span class="sd">            The name of the choice to listen for exercises on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_register_exercised</span><span class="p">(</span><span class="n">cb</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[ContractExercisedEvent]&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandler[ContractExercisedEvent]&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_exercised</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">cb</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cb</span>

        <span class="k">return</span> <span class="n">_register_exercised</span></div>

<div class="viewcode-block" id="AIOPartyClient.add_ledger_exercised"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.add_ledger_exercised">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_exercised</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[ContractExercisedEvent]&#39;</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters an exercised</span>
<span class="sd">        choice event.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param choice:</span>
<span class="sd">            The name of the choice to listen for exercises on.</span>
<span class="sd">        :param handler:</span>
<span class="sd">            The callback to invoke whenever a matching template is exercised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">contract_exercised</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.ledger_archived"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ledger_archived">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_archived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;Optional[ContractMatch]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandlerDecorator[ContractArchiveEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` encounters</span>
<span class="sd">        a newly archived contract instance of a template.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An (optional) parameter that filters the templates to be received by the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_register_archived</span><span class="p">(</span><span class="n">cb</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[ContractArchiveEvent]&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;AEventHandler[ContractArchiveEvent]&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_archived</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">cb</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cb</span>

        <span class="k">return</span> <span class="n">_register_archived</span></div>

<div class="viewcode-block" id="AIOPartyClient.add_ledger_archived"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.add_ledger_archived">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_archived</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;AEventHandler[ContractArchiveEvent]&#39;</span><span class="p">,</span>
            <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;Optional[ContractMatch]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters a newly archived</span>
<span class="sd">        contract instance of a template.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param handler:</span>
<span class="sd">            The callback to invoke whenever a matching template is created.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An (optional) parameter that filters the templates to be received by the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">contract_archived</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Command submission&quot;&gt;</span>

<div class="viewcode-block" id="AIOPartyClient.submit"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.submit">[docs]</a>    <span class="k">def</span> <span class="nf">submit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">commands</span><span class="p">:</span> <span class="s1">&#39;EventHandlerResponse&#39;</span><span class="p">,</span> <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submit commands to the ledger.</span>

<span class="sd">        :param commands:</span>
<span class="sd">            An object that can be converted to a command.</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        :return:</span>
<span class="sd">            A future that resolves when the command has made it to the ledger _or_ an error</span>
<span class="sd">            occurred when trying to process them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">write_commands</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.submit_create"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.submit_create">[docs]</a>    <span class="k">def</span> <span class="nf">submit_create</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">template_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Optional[dict]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submit a single create command. Equivalent to calling :meth:`submit` with a single</span>
<span class="sd">        ``create``.</span>

<span class="sd">        :param template_name:</span>
<span class="sd">            The name of the template.</span>
<span class="sd">        :param arguments:</span>
<span class="sd">            The arguments to the create (as a ``dict``).</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        :return:</span>
<span class="sd">            A future that resolves when the command has made it to the ledger _or_ an error</span>
<span class="sd">            occurred when trying to process them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">create</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">create</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">),</span> <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.submit_exercise"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.submit_exercise">[docs]</a>    <span class="k">def</span> <span class="nf">submit_exercise</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cid</span><span class="p">:</span> <span class="s1">&#39;ContractId&#39;</span><span class="p">,</span>
            <span class="n">choice_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Optional[dict]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submit a single exercise choice. Equivalent to calling :meth:`submit` with a single</span>
<span class="sd">        ``exercise``.</span>

<span class="sd">        :param cid:</span>
<span class="sd">            The :class:`ContractId` on which a choice is being exercised.</span>
<span class="sd">        :param choice_name:</span>
<span class="sd">            The name of the choice to exercise.</span>
<span class="sd">        :param arguments:</span>
<span class="sd">            The arguments to the exercise (as a ``dict``). Can be omitted (``None``) for no-argument</span>
<span class="sd">            choices.</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        :return:</span>
<span class="sd">            A future that resolves when the command has made it to the ledger _or_ an error</span>
<span class="sd">            occurred when trying to process them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">exercise</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">exercise</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">choice_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">),</span> <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.submit_exercise_by_key"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.submit_exercise_by_key">[docs]</a>    <span class="k">def</span> <span class="nf">submit_exercise_by_key</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">template_name</span><span class="p">:</span> <span class="s1">&#39;TemplateNameLike&#39;</span><span class="p">,</span>
            <span class="n">contract_key</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
            <span class="n">choice_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Optional[dict]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously submit a single exercise choice. Equivalent to calling :meth:`submit` with a</span>
<span class="sd">        single ``exercise_by_key``.</span>

<span class="sd">        :param template_name:</span>
<span class="sd">            The name of the template on which to do an exercise-by-key.</span>
<span class="sd">        :param contract_key:</span>
<span class="sd">            The value that should uniquely identify a contract for the specified template.</span>
<span class="sd">        :param choice_name:</span>
<span class="sd">            The name of the choice to exercise.</span>
<span class="sd">        :param arguments:</span>
<span class="sd">            The arguments to the create (as a ``dict``). Can be omitted (``None``) for no-argument</span>
<span class="sd">            choices.</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">exercise_by_key</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
            <span class="n">exercise_by_key</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="n">contract_key</span><span class="p">,</span> <span class="n">choice_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">),</span> <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.submit_create_and_exercise"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.submit_create_and_exercise">[docs]</a>    <span class="k">def</span> <span class="nf">submit_create_and_exercise</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">template_name</span><span class="p">:</span> <span class="s1">&#39;TemplateNameLike&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;dict&#39;</span><span class="p">,</span>
            <span class="n">choice_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">choice_arguments</span><span class="p">:</span> <span class="s1">&#39;Optional[dict]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously submit a single create-and-exercise command. Equivalent to calling</span>
<span class="sd">        :meth:`submit` with a single ``create_and_exercise``.</span>

<span class="sd">        :param template_name:</span>
<span class="sd">            The name of the template on which to do an exercise-by-key.</span>
<span class="sd">        :param arguments:</span>
<span class="sd">            The arguments to the create (as a ``dict``).</span>
<span class="sd">        :param choice_name:</span>
<span class="sd">            The name of the choice to exercise.</span>
<span class="sd">        :param choice_arguments:</span>
<span class="sd">            The arguments to the exercise (as a ``dict``). Can be omitted (``None``) for no-argument</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">create_and_exercise</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
            <span class="n">create_and_exercise</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">choice_name</span><span class="p">,</span> <span class="n">choice_arguments</span><span class="p">),</span>
            <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Active contract set&quot;&gt;</span>

<div class="viewcode-block" id="AIOPartyClient.find_by_id"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.find_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">find_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cid</span><span class="p">:</span> <span class="s1">&#39;Union[str, ContractId]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Optional[ContractContextualData]&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find_by_id</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.find"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
             <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;ContractMatch&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">include_archived</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">ContractContextualDataCollection</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">include_archived</span><span class="o">=</span><span class="n">include_archived</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.find_active"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.find_active">[docs]</a>    <span class="k">def</span> <span class="nf">find_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;ContractMatch&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ContractsState&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Immediately return data from the current active contract set.</span>

<span class="sd">        The contents of this ACS are guaranteed to be present (or removed) in the current</span>
<span class="sd">        transaction _before_ processing any corresponding ``on_created`` or ``on_archived``</span>
<span class="sd">        callbacks for this party. The ACS is populated _before_ processing any ``on_ready``</span>
<span class="sd">        callbacks.</span>

<span class="sd">        This method raises an error if ACS tracking has been disabled on this client.</span>

<span class="sd">        :param template:</span>
<span class="sd">            The name of the template to fetch data from.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An optional dictionary whose keys are matched against corresponding field values.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``dict`` whose keys are :class:`ContractId` and values are corresponding contract</span>
<span class="sd">            data that match the current query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find_active</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.find_historical"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.find_historical">[docs]</a>    <span class="k">def</span> <span class="nf">find_historical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;ContractMatch&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;ContractContextualDataCollection&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Immediately return data from the current active and historical contract set as</span>
<span class="sd">        a contextual data collection</span>

<span class="sd">        The contents of this set are guaranteed to be up-to-date in the current transaction _before_</span>
<span class="sd">        processing any corresponding ``on_created`` or ``on_archived`` callbacks for this party. The</span>
<span class="sd">        set is up-to-date _before_ processing any ``on_ready`` callbacks.</span>

<span class="sd">        This method raises an error if historical tracking has been disabled on this client.</span>

<span class="sd">        :param template:</span>
<span class="sd">            The name of the template to fetch data from.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An optional dictionary whose keys are matched against corresponding field values.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``ContractContextualDataCollection`` whose values correspond to the contract</span>
<span class="sd">            data for active and archived contracts matching the current query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find_historical</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.find_one"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.find_one">[docs]</a>    <span class="k">def</span> <span class="nf">find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;ContractMatch&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[Tuple[ContractId, ContractData]]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data from the current active contract set when at least some amount of rows exist in</span>
<span class="sd">        the active contract set.</span>

<span class="sd">        :param template:</span>
<span class="sd">            The name of the template to fetch data from.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An optional dictionary whose keys are matched against corresponding field values.</span>
<span class="sd">        :param timeout:</span>
<span class="sd">            Number of seconds in which to time out the search.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``Future`` that is resolved with a ``dict`` whose keys are :class:`ContractId` and</span>
<span class="sd">            values are corresponding contract data that match the current query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">await_then</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">find_nonempty</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">state</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span></div>

<div class="viewcode-block" id="AIOPartyClient.find_nonempty"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.find_nonempty">[docs]</a>    <span class="k">def</span> <span class="nf">find_nonempty</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;ContractMatch&#39;</span><span class="p">,</span> <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[ContractsState]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data from the current active contract set when at least some amount of rows exist in</span>
<span class="sd">        the active contract set.</span>

<span class="sd">        :param template:</span>
<span class="sd">            The name of the template to fetch data from.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An optional dictionary whose keys are matched against corresponding field values.</span>
<span class="sd">        :param min_count:</span>
<span class="sd">            The minimum number of rows to return. The default value is 1.</span>
<span class="sd">        :param timeout:</span>
<span class="sd">            Number of seconds in which to time out the search.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``Future`` that is resolved with a ``dict`` whose keys are :class:`ContractId` and</span>
<span class="sd">            values are corresponding contract data that match the current query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find_nonempty</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">min_count</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Ledger/client metadata&quot;&gt;</span>

<div class="viewcode-block" id="AIOPartyClient.set_config"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.set_config">[docs]</a>    <span class="k">def</span> <span class="nf">set_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.get_time"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.get_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[datetime]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current time on the remote server. Also advance the local notion of time if</span>
<span class="sd">        required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span></div>

<div class="viewcode-block" id="AIOPartyClient.set_time"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.set_time">[docs]</a>    <span class="k">def</span> <span class="nf">set_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_datetime</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the current time on the ledger. This is only supported if the ledger supports time</span>
<span class="sd">        manipulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">set_time</span><span class="p">(</span><span class="n">new_datetime</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIOPartyClient.ready"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.AIOPartyClient.ready">[docs]</a>    <span class="k">def</span> <span class="nf">ready</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[None]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Block until the ledger client has caught up to the current head and is ready to send</span>
<span class="sd">        commands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">ready</span><span class="p">()</span></div></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>


<div class="viewcode-block" id="SimplePartyClient"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient">[docs]</a><span class="k">class</span> <span class="nc">SimplePartyClient</span><span class="p">(</span><span class="n">PartyClient</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of a :class:`PartyClient` that exposes blocking calls, but can be used from any</span>
<span class="sd">    thread.</span>

<span class="sd">    Use this implementation if any of these apply:</span>
<span class="sd">      * you wish to interact with libraries that do not natively support asyncio</span>
<span class="sd">      * you are comfortable with the trade-off of having to block threads in order to write code</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Event handler registration&quot;&gt;</span>

<div class="viewcode-block" id="SimplePartyClient.ledger_init"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ledger_init">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;EventHandlerDecorator[InitEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` has been</span>
<span class="sd">        instructed to begin, but before any network activity is started.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_init</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.add_ledger_init"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.add_ledger_init">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;EventHandler[InitEvent]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` has been instructed to</span>
<span class="sd">        begin, but before any network activity is started.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. May return anything that can be successfully coerced into a</span>
<span class="sd">            :class:`CommandPayload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_background_ledger_init</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="s1">&#39;InitEvent&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[EventHandlerResponse]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">init</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_background_ledger_init</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.ledger_ready"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ledger_ready">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;EventHandlerDecorator[ReadyEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` has caught</span>
<span class="sd">        up to the head of the ledger, but before any :meth:`ledger_create` or :meth:`ledger_archive`</span>
<span class="sd">        callbacks are invoked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_ready</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.add_ledger_ready"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.add_ledger_ready">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;EventHandler[ReadyEvent]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` has caught up to the head of</span>
<span class="sd">        the ledger, but before any :meth:`ledger_create` or :meth:`ledger_archive` callbacks are</span>
<span class="sd">        invoked.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. May return anything that can be successfully coerced into a</span>
<span class="sd">            :class:`CommandPayload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_background_ledger_ready</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="s1">&#39;ReadyEvent&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[EventHandlerResponse]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">ready</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_background_ledger_ready</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.ledger_packages_added"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ledger_packages_added">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_packages_added</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;EventHandlerDecorator[PackagesAddedEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` has</span>
<span class="sd">        detected new packages added to the ledger.</span>

<span class="sd">        :param initial:</span>
<span class="sd">            ``True`` to call the handler when the client is ready. This can be useful if you want</span>
<span class="sd">            to handle package additions identically whether they were already in the ledger when</span>
<span class="sd">            the client started up or only after a package has been added. The default value is</span>
<span class="sd">            ``False``, which means that this handler is only called on NEW packages that have been</span>
<span class="sd">            uploaded after this client has started.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_packages_added</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.add_ledger_packages_added"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.add_ledger_packages_added">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_packages_added</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;EventHandler[PackagesAddedEvent]&#39;</span><span class="p">,</span> <span class="n">initial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` has detected new packages</span>
<span class="sd">        added to the ledger.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. May return anything that can be successfully coerced into a</span>
<span class="sd">            :class:`CommandPayload`.</span>
<span class="sd">        :param initial:</span>
<span class="sd">            ``True`` to call the handler when the client is ready. This can be useful if you want</span>
<span class="sd">            to handle package additions identically whether they were already in the ledger when</span>
<span class="sd">            the client started up or only after a package has been added. The default value is</span>
<span class="sd">            ``False``, which means that this handler is only called on NEW packages that have been</span>
<span class="sd">            uploaded after this client has started.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_background_ledger_packages_added</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="s1">&#39;PackagesAddedEvent&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[EventHandlerResponse]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">packages_added</span><span class="p">(</span><span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span> <span class="n">changed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_background_ledger_packages_added</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.ledger_transaction_start"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ledger_transaction_start">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_transaction_start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;EventHandlerDecorator[TransactionStartEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` receives a</span>
<span class="sd">        new transaction. Called before individual :meth:`ledger_create` and :meth:`ledger_archive`</span>
<span class="sd">        callbacks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fluentize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_transaction_start</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.add_ledger_transaction_start"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.add_ledger_transaction_start">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_transaction_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;EventHandler[TransactionStartEvent]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` receives a new transaction.</span>
<span class="sd">        Called before individual :meth:`ledger_create` and :meth:`ledger_archive` callbacks.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. This can either be a coroutine or a normal function, and may</span>
<span class="sd">            return anything that can be successfully coerced into a :class:`CommandPayload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_background_ledger_transaction_start</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">TransactionStartEvent</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="n">Awaitable</span><span class="p">[</span><span class="n">EventHandlerResponse</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">transaction_start</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_background_ledger_transaction_start</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.ledger_transaction_end"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ledger_transaction_end">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_transaction_end</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;EventHandlerDecorator[TransactionEndEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` receives a</span>
<span class="sd">        new transaction. Called after individual :meth:`ledger_create` and :meth:`ledger_archive`</span>
<span class="sd">        callbacks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_register_transaction_end</span><span class="p">(</span><span class="n">cb</span><span class="p">:</span> <span class="s1">&#39;EventHandler[TransactionEndEvent]&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;EventHandler[TransactionEndEvent]&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_transaction_end</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cb</span>

        <span class="k">return</span> <span class="n">_register_transaction_end</span></div>

<div class="viewcode-block" id="SimplePartyClient.add_ledger_transaction_end"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.add_ledger_transaction_end">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_transaction_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;EventHandler[TransactionEndEvent]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` receives a new transaction.</span>
<span class="sd">        Called after individual :meth:`ledger_create` and :meth:`ledger_archive` callbacks.</span>

<span class="sd">        :param handler:</span>
<span class="sd">            The handler to register. This can either be a coroutine or a normal function, and may</span>
<span class="sd">            return anything that can be successfully coerced into a :class:`CommandPayload`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_background_ledger_transaction_end</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="s1">&#39;TransactionEndEvent&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[EventHandlerResponse]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">transaction_end</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_background_ledger_transaction_end</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.ledger_created"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ledger_created">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_created</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;Optional[ContractMatch]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;EventHandlerDecorator[ContractCreateEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters a newly created</span>
<span class="sd">        template.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An (optional) parameter that filters the templates to be received by the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_register_created</span><span class="p">(</span><span class="n">cb</span><span class="p">:</span> <span class="s1">&#39;EventHandler[ContractCreateEvent]&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;EventHandler[ContractCreateEvent]&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_created</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">cb</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cb</span>

        <span class="k">return</span> <span class="n">_register_created</span></div>

<div class="viewcode-block" id="SimplePartyClient.add_ledger_created"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.add_ledger_created">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_created</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;EventHandler[ContractCreateEvent]&#39;</span><span class="p">,</span>
            <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;Optional[ContractMatch]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters a newly created</span>
<span class="sd">        contract instance of a template.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param handler:</span>
<span class="sd">            The callback to invoke whenever a matching template is created.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An (optional) parameter that filters the templates to be received by the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_background_ledger_contract_create</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="s1">&#39;ContractCreateEvent&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[EventHandlerResponse]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">contract_created</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_background_ledger_contract_create</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.ledger_exercised"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ledger_exercised">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_exercised</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;EventHandlerDecorator[ContractExercisedEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters an exercised</span>
<span class="sd">        choice event.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param choice:</span>
<span class="sd">            The name of the choice to listen for exercises on.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_register_exercised</span><span class="p">(</span><span class="n">cb</span><span class="p">:</span> <span class="s1">&#39;EventHandler[ContractExercisedEvent]&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;EventHandler[ContractExercisedEvent]&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_exercised</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">cb</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cb</span>

        <span class="k">return</span> <span class="n">_register_exercised</span></div>

<div class="viewcode-block" id="SimplePartyClient.add_ledger_exercised"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.add_ledger_exercised">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_exercised</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;EventHandler[ContractExercisedEvent]&#39;</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters an exercised</span>
<span class="sd">        choice event.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param choice:</span>
<span class="sd">            The name of the choice to listen for exercises on.</span>
<span class="sd">        :param handler:</span>
<span class="sd">            The callback to invoke whenever a matching template is exercised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_background_ledger_contract_exercised</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="s1">&#39;ContractExercisedEvent&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[EventHandlerResponse]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">contract_exercised</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_background_ledger_contract_exercised</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.ledger_archived"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ledger_archived">[docs]</a>    <span class="k">def</span> <span class="nf">ledger_archived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;Optional[ContractMatch]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;EventHandlerDecorator[ContractArchiveEvent]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator for registering a callback to be invoked when the :class:`PartyClient` encounters</span>
<span class="sd">        a newly archived contract instance of a template.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An (optional) parameter that filters the templates to be received by the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_register_archived</span><span class="p">(</span><span class="n">cb</span><span class="p">:</span> <span class="s1">&#39;EventHandler[ContractArchiveEvent]&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;EventHandler[ContractArchiveEvent]&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_ledger_archived</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">cb</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cb</span>

        <span class="k">return</span> <span class="n">_register_archived</span></div>

<div class="viewcode-block" id="SimplePartyClient.add_ledger_archived"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.add_ledger_archived">[docs]</a>    <span class="k">def</span> <span class="nf">add_ledger_archived</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="s1">&#39;EventHandler[ContractArchiveEvent]&#39;</span><span class="p">,</span>
            <span class="n">match</span><span class="p">:</span> <span class="s1">&#39;Optional[ContractMatch]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a callback to be invoked when the :class:`PartyClient` encounters a newly archived</span>
<span class="sd">        contract instance of a template.</span>

<span class="sd">        :param template:</span>
<span class="sd">            A template name to subscribe to, or &#39;*&#39; to subscribe on all templates.</span>
<span class="sd">        :param handler:</span>
<span class="sd">            The callback to invoke whenever a matching template is created.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An (optional) parameter that filters the templates to be received by the callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_background_ledger_contract_archived</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="s1">&#39;ContractArchiveEvent&#39;</span><span class="p">)</span> \
                <span class="o">-&gt;</span> <span class="s1">&#39;Awaitable[EventHandlerResponse]&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">EventKey</span><span class="o">.</span><span class="n">contract_archived</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">add_event_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_background_ledger_contract_archived</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>

    <span class="c1"># region Command submission</span>

<div class="viewcode-block" id="SimplePartyClient.submit_create"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.submit_create">[docs]</a>    <span class="k">def</span> <span class="nf">submit_create</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">template_name</span><span class="p">:</span> <span class="s1">&#39;TemplateNameLike&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Optional[dict]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously submit a single create command. Equivalent to calling :meth:`submit` with a</span>
<span class="sd">        single ``create``.</span>

<span class="sd">        :param template_name:</span>
<span class="sd">            The name of the template.</span>
<span class="sd">        :param arguments:</span>
<span class="sd">            The arguments to the create (as a ``dict``).</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">create</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">create</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">),</span> <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.submit_exercise"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.submit_exercise">[docs]</a>    <span class="k">def</span> <span class="nf">submit_exercise</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cid</span><span class="p">:</span> <span class="s1">&#39;ContractId&#39;</span><span class="p">,</span>
            <span class="n">choice_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Optional[dict]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously submit a single exercise choice. Equivalent to calling :meth:`submit` with a</span>
<span class="sd">        single ``exercise``.</span>

<span class="sd">        :param cid:</span>
<span class="sd">            The :class:`ContractId` on which a choice is being exercised.</span>
<span class="sd">        :param choice_name:</span>
<span class="sd">            The name of the choice to exercise.</span>
<span class="sd">        :param arguments:</span>
<span class="sd">            The arguments to the exercise (as a ``dict``). Can be omitted (``None``) for no-argument</span>
<span class="sd">            choices.</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">exercise</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">exercise</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">choice_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">),</span> <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.submit_exercise_by_key"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.submit_exercise_by_key">[docs]</a>    <span class="k">def</span> <span class="nf">submit_exercise_by_key</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">template_name</span><span class="p">:</span> <span class="s1">&#39;TemplateNameLike&#39;</span><span class="p">,</span>
            <span class="n">contract_key</span><span class="p">:</span> <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
            <span class="n">choice_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;Optional[dict]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously submit a single exercise choice. Equivalent to calling :meth:`submit` with a</span>
<span class="sd">        single ``exercise_by_key``.</span>

<span class="sd">        :param template_name:</span>
<span class="sd">            The name of the template on which to do an exercise-by-key.</span>
<span class="sd">        :param contract_key:</span>
<span class="sd">            The value that should uniquely identify a contract for the specified template.</span>
<span class="sd">        :param choice_name:</span>
<span class="sd">            The name of the choice to exercise.</span>
<span class="sd">        :param arguments:</span>
<span class="sd">            The arguments to the create (as a ``dict``). Can be omitted (``None``) for no-argument</span>
<span class="sd">            choices.</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">exercise_by_key</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
            <span class="n">exercise_by_key</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="n">contract_key</span><span class="p">,</span> <span class="n">choice_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">),</span>
            <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.submit_create_and_exercise"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.submit_create_and_exercise">[docs]</a>    <span class="k">def</span> <span class="nf">submit_create_and_exercise</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">template_name</span><span class="p">:</span> <span class="s1">&#39;TemplateNameLike&#39;</span><span class="p">,</span>
            <span class="n">arguments</span><span class="p">:</span> <span class="s1">&#39;dict&#39;</span><span class="p">,</span>
            <span class="n">choice_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">choice_arguments</span><span class="p">:</span> <span class="s1">&#39;Optional[dict]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">workflow_id</span><span class="p">:</span> <span class="s1">&#39;Optional[str]&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronously submit a single create-and-exercise command. Equivalent to calling</span>
<span class="sd">        :meth:`submit` with a single ``create_and_exercise``.</span>

<span class="sd">        :param template_name:</span>
<span class="sd">            The name of the template on which to do an exercise-by-key.</span>
<span class="sd">        :param arguments:</span>
<span class="sd">            The arguments to the create (as a ``dict``).</span>
<span class="sd">        :param choice_name:</span>
<span class="sd">            The name of the choice to exercise.</span>
<span class="sd">        :param choice_arguments:</span>
<span class="sd">            The arguments to the exercise (as a ``dict``). Can be omitted (``None``) for no-argument</span>
<span class="sd">        :param workflow_id:</span>
<span class="sd">            The optional workflow ID to stamp on the outgoing command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">create_and_exercise</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
            <span class="n">create_and_exercise</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">choice_name</span><span class="p">,</span> <span class="n">choice_arguments</span><span class="p">),</span>
            <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">)</span></div>

    <span class="c1"># endregion</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Active contract set&quot;&gt;</span>

<div class="viewcode-block" id="SimplePartyClient.find_by_id"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.find_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">find_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cid</span><span class="p">:</span> <span class="s1">&#39;Union[str, ContractId]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Optional[ContractContextualData]&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find_by_id</span><span class="p">(</span><span class="n">cid</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimplePartyClient.find"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
             <span class="n">match</span><span class="p">:</span> <span class="n">ContractMatch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">include_archived</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">ContractContextualDataCollection</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">include_archived</span><span class="o">=</span><span class="n">include_archived</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimplePartyClient.find_active"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.find_active">[docs]</a>    <span class="k">def</span> <span class="nf">find_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">ContractMatch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContractsState</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Immediately return data from the current active contract set.</span>

<span class="sd">        The contents of this ACS are guaranteed to be present (or removed) in the current</span>
<span class="sd">        transaction _before_ processing any corresponding ``on_created`` or ``on_archived``</span>
<span class="sd">        callbacks for this party. The ACS is populated _before_ processing any ``on_ready``</span>
<span class="sd">        callbacks.</span>

<span class="sd">        This method raises an error if ACS tracking has been disabled on this client.</span>

<span class="sd">        :param template:</span>
<span class="sd">            The name of the template to fetch data from.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An optional dictionary whose keys are matched against corresponding field values.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``dict`` whose keys are :class:`ContractId` and values are corresponding contract</span>
<span class="sd">            data that match the current query.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``dict`` whose keys are :class:`ContractId` and values are corresponding contract</span>
<span class="sd">            data that match the current query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find_active</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimplePartyClient.find_historical"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.find_historical">[docs]</a>    <span class="k">def</span> <span class="nf">find_historical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">ContractMatch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">ContractContextualDataCollection</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Immediately return data from the current active and historical contract set.</span>

<span class="sd">        The contents of this set are guaranteed to be up-to-date in the current transaction _before_</span>
<span class="sd">        processing any corresponding ``on_created`` or ``on_archived`` callbacks for this party. The</span>
<span class="sd">        set is up-to-date _before_ processing any ``on_ready`` callbacks.</span>

<span class="sd">        This method raises an error if historical tracking has been disabled on this client.</span>

<span class="sd">        :param template:</span>
<span class="sd">            The name of the template to fetch data from.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An optional dictionary whose keys are matched against corresponding field values.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``dict`` whose keys are :class:`ContractId` and values are corresponding contract</span>
<span class="sd">            data that match the current query.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``dict`` whose keys are :class:`ContractId` and values are corresponding contract</span>
<span class="sd">            data that match the current query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find_historical</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimplePartyClient.find_one"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.find_one">[docs]</a>    <span class="k">def</span> <span class="nf">find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">ContractMatch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ContractId</span><span class="p">,</span> <span class="n">ContractData</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data from the current active contract set when at least some amount of rows exist in</span>
<span class="sd">        the active contract set.</span>

<span class="sd">        :param template:</span>
<span class="sd">            The name of the template to fetch data from.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An optional dictionary whose keys are matched against corresponding field values.</span>
<span class="sd">        :param timeout:</span>
<span class="sd">            Number of seconds in which to time out the search.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``Future`` that is resolved with a ``dict`` whose keys are :class:`ContractId` and</span>
<span class="sd">            values are corresponding contract data that match the current query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nonempty</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span></div>

<div class="viewcode-block" id="SimplePartyClient.find_nonempty"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.find_nonempty">[docs]</a>    <span class="k">def</span> <span class="nf">find_nonempty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">ContractMatch</span><span class="p">,</span> <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT_SECONDS</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">ContractsState</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data from the current active contract set when at least some amount of rows exist in</span>
<span class="sd">        the active contract set.</span>

<span class="sd">        :param template:</span>
<span class="sd">            The name of the template to fetch data from.</span>
<span class="sd">        :param match:</span>
<span class="sd">            An optional dictionary whose keys are matched against corresponding field values.</span>
<span class="sd">        :param min_count:</span>
<span class="sd">            The minimum number of rows to return. The default value is 1.</span>
<span class="sd">        :param timeout:</span>
<span class="sd">            Number of seconds in which to time out the search.</span>
<span class="sd">        :return:</span>
<span class="sd">            A ``Future`` that is resolved with a ``dict`` whose keys are :class:`ContractId` and</span>
<span class="sd">            values are corresponding contract data that match the current query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">find_nonempty</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="n">min_count</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">))</span></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>

    <span class="c1"># &lt;editor-fold desc=&quot;Ledger/client metadata&quot;&gt;</span>

<div class="viewcode-block" id="SimplePartyClient.set_config"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.set_config">[docs]</a>    <span class="k">def</span> <span class="nf">set_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimplePartyClient.get_time"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.get_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_time</span><span class="p">())</span></div>

<div class="viewcode-block" id="SimplePartyClient.set_time"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.set_time">[docs]</a>    <span class="k">def</span> <span class="nf">set_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_datetime</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">set_time</span><span class="p">(</span><span class="n">new_datetime</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimplePartyClient.submit"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.submit">[docs]</a>    <span class="k">def</span> <span class="nf">submit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">commands</span><span class="p">,</span> <span class="n">workflow_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">write_commands</span><span class="p">(</span><span class="n">commands</span><span class="p">,</span> <span class="n">workflow_id</span><span class="o">=</span><span class="n">workflow_id</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimplePartyClient.ready"><a class="viewcode-back" href="../../../dazl.client.html#dazl.client.api.SimplePartyClient.ready">[docs]</a>    <span class="k">def</span> <span class="nf">ready</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Block until the underlying infrastructure has connected to all necessary services.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Improve on this implementation; this spin loop is unnecessarily ugly</span>
        <span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">sleep</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">get_loop</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Waiting for the underlying implementation to be ready...&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">invoker</span><span class="o">.</span><span class="n">run_in_loop</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">ready</span><span class="p">())</span></div></div>

    <span class="c1"># &lt;/editor-fold&gt;</span>
</pre></div>

  </main>

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'',
            VERSION:'unknown',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <footer> 
  </footer>
</body>
</html>